
/**
 * Generated by https://github.com/dsheiko/puppetry
 * on Sun Nov 20 2022 21:39:20 GMT+0900 (日本標準時)
 * Suite: Sandbox RWD
 */

var nVer = process.version.match( /^v(\d+)/ );
if ( !nVer || nVer[ 1 ] < 9 ) {
  console.error( "WARNING: You have an outdated Node.js version " + process.version
    + ". You need at least v.9.x to run this test suite." );
}


const {
        bs, util, fetch, localStorage
      } = require( "../lib/bootstrap" )( "Sandbox--RWD" ),
      puppeteerOptions = require( "../puppeteer.config.json" ),
      devices = require( "puppeteer" ).devices,
      fs = require( "fs" ),
      path = require( "path" ),
      os = require( "os" );




jest.setTimeout( 50000 );

let consoleLog = [], // assetConsoleMessage
    dialogLog = []; // assertDialog;

bs.TARGETS = {};

// Environment variables
let ENV = {
  "SANDBOX_BASEURL": "https://puppetry.app/demo/"
};

bs.TARGETS[ "FIRSTNAME_INPUT" ] = async () => await bs.query( "#fname", true, "FIRSTNAME_INPUT" );
bs.TARGETS[ "LASTNAME_INPUT" ] = async () => await bs.query( "#lname", true, "LASTNAME_INPUT" );
bs.TARGETS[ "MESSAGE_INPUT" ] = async () => await bs.query( "#comment", true, "MESSAGE_INPUT" );
bs.TARGETS[ "CONSENT_CHECKBOX" ] = async () => await bs.query( "#consent", true, "CONSENT_CHECKBOX" );
bs.TARGETS[ "OPTION_RADIO_1" ] = async () => await bs.query( "#option1", true, "OPTION_RADIO_1" );
bs.TARGETS[ "ATTACHMENT_FILE" ] = async () => await bs.query( "#attachment", true, "ATTACHMENT_FILE" );
bs.TARGETS[ "FORM" ] = async () => await bs.query( "#form", true, "FORM" );
bs.TARGETS[ "SUBMIT_BTN" ] = async () => await bs.query( "#submit", true, "SUBMIT_BTN" );
bs.TARGETS[ "MAIN_NAV" ] = async () => await bs.query( "#nav-mobile", true, "MAIN_NAV" );
bs.TARGETS[ "PRODUCT_WHITE" ] = async () => await bs.query( ".main-container > .row .col:nth-child(1) .product", true, "PRODUCT_WHITE" );
bs.TARGETS[ "PRODUCT_BLACK" ] = async () => await bs.query( ".main-container > .row .col:nth-child(2) .product", true, "PRODUCT_BLACK" );

describe( "Sandbox RWD", () => {
  beforeAll(async () => {
    await bs.setup( puppeteerOptions, {"allure":false,"requireInterceptTraffic":true});
    await util.once(async () => {
      bs.browser && console.log( "BROWSER: ", await bs.browser.version() );
      await util.savePuppetterInfo( bs );
    });

    bs.page.on( "console", ( message ) => consoleLog.push( message ) );
    bs.page.on( "dialog", ( dialog ) => dialogLog.push( dialog ) );

    
    bs.performance.watchTraffic();

    
  });

  afterAll(async () => {

    await bs.teardown();
  });


  describe( "Sandbox RWD", () => {

    test( "on Desktop {dduk2fx8bwf}", async () => {
      let result, assert, searchStr, localEnv;

      // Defining browser viewport
      await bs.page.setViewport({
        width: 1920,
        height: 1080,
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        isLandscape: false
      });
  

      // Navigating to {{ SANDBOX_BASEURL }}
      bs.performance.reset();
      await bs.page.goto( `${ ENV[ "SANDBOX_BASEURL" ] }`, {"timeout":30000,"waitUntil":"load"} );
    
      
      // Asserting that MAIN_NAV element is visible
      result = await bs.target( await bs.getTargetOrFalse("MAIN_NAV") ).isVisible();       
      expect( result ).toBeVisible( {"assertion":"visible","availability":"visible","display":"any","visibility":"any","opacity":"any","isIntersecting":"any"}, "MAIN_NAV.assertVisible" );
      
      // Asserting that the bounding box of the element satisfies the given constraint
      result = {
              target: await ( await bs.getTarget( "PRODUCT_WHITE" ) ).boundingBox(),
              counterpart: await ( await bs.getTarget( "PRODUCT_BLACK" ) ).boundingBox()
            };       
      expect( result ).toMatchPosition( "left", "PRODUCT_WHITE", "PRODUCT_BLACK", "PRODUCT_WHITE.assertPosition" );

      // Taking screenshot of the page
      await bs.page.screenshot( util.png( "jotk2g46k0o", null, "on Desktop" ) );

    });


    test( "on iPhone X {jotk2g3449f}", async () => {
      let result, assert, searchStr, localEnv;

      // Emulating device "iPhone X"
      await bs.page.emulate( devices[ "iPhone X" ] );
  

      // Navigating to {{ SANDBOX_BASEURL }}
      bs.performance.reset();
      await bs.page.goto( `${ ENV[ "SANDBOX_BASEURL" ] }`, {"timeout":30000,"waitUntil":"load"} );
    
      
      // Asserting that MAIN_NAV element is visible
      result = await bs.target( await bs.getTargetOrFalse("MAIN_NAV") ).isVisible();       
      expect( result ).toBeVisible( {"assertion":"visible","value":true,"display":"none","visibility":"any","opacity":"any","isIntersecting":false}, "MAIN_NAV.assertVisible" );
      
      // Asserting that the bounding box of the element satisfies the given constraint
      result = {
              target: await ( await bs.getTarget( "PRODUCT_WHITE" ) ).boundingBox(),
              counterpart: await ( await bs.getTarget( "PRODUCT_BLACK" ) ).boundingBox()
            };       
      expect( result ).toMatchPosition( "above", "PRODUCT_WHITE", "PRODUCT_BLACK", "PRODUCT_WHITE.assertPosition" );

      // Taking screenshot of the page
      await bs.page.screenshot( util.png( "jotk2g473s3", null, "on iPhone X" ) );

    });

  });


});
